import os  # 导入操作系统相关功能
import platform  # 导入平台识别模块，用于检测操作系统类型
import subprocess  # 导入子进程模块，用于启动Chrome浏览器
from dotenv import load_dotenv  # 导入环境变量加载模块
from pathlib import Path  # 导入路径处理模块
import asyncio  # 导入异步IO模块
import json  # 导入JSON处理模块
from playwright.async_api import async_playwright  # 导入Playwright相关类

# 加载环境变量，override=True表示环境变量会覆盖已存在的系统环境变量
load_dotenv(override=True)

def get_chrome_binary_path():
    """
    获取Chrome浏览器二进制文件的路径
    如果.env文件存在，则从中读取CHROME_BINARY_PATH
    否则根据操作系统返回默认路径
    
    Returns:
        str: Chrome浏览器可执行文件的路径
    """
    # 检查.env文件是否存在并加载
    env_path = Path('.') / '.env'
    if env_path.exists():
        load_dotenv()
        chrome_path = os.getenv('CHROME_BINARY_PATH')
        if chrome_path:
            return chrome_path
    
    # 根据操作系统确定默认路径
    system = platform.system()
    if system == 'Windows':
        # Windows默认Chrome路径
        return r"C:\Program Files\Google\Chrome\Application\chrome.exe"
    elif system == 'Darwin':  # macOS
        # macOS默认Chrome路径
        return "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
    elif system == 'Linux':
        # Linux默认Chrome路径
        return "/usr/bin/google-chrome"
    else:
        # 不支持的操作系统
        raise Exception(f"不支持的操作系统: {system}")

def launch_chrome_with_remote_debugging(port=9222, user_data="./user_data"):
    """
    启动Chrome浏览器并开启远程调试端口
    
    Args:
        port (int): 远程调试端口号，默认为9222
        user_data (str): 用户数据目录，默认为./user_data
    
    Returns:
        subprocess.Popen: 启动的Chrome进程对象
    """
    # 获取Chrome浏览器路径
    chrome_path = get_chrome_binary_path()
    print(f"使用Chrome路径: {chrome_path}")
    
    # 构建用户数据目录的完整路径
    user_data_path = Path(__file__).resolve().parent.joinpath(user_data)
    # 确保用户数据目录存在
    user_data_path.mkdir(parents=True, exist_ok=True) # parents=True 确保父目录也创建
    
    # 构建Chrome启动命令
    cmd = [
        chrome_path,
        f"--remote-debugging-port={port}",  # 设置远程调试端口
        f"--user-data-dir={user_data_path}"  # 设置用户数据目录
    ]
    
    # 启动Chrome进程
    print(f"启动Chrome，远程调试端口: {port}")
    process = subprocess.Popen(cmd)
    
    # 等待用户登录网站
    prompt = input("请先登录YouTube网站，如果不需要登录可跳过；按任意键继续...")
    return process

async def save_cookies_async(output_file='cookies.txt'): # 增加 output_file 参数
    """
    异步连接到Chrome并保存cookies到文件
    
    Args:
        output_file (str): 保存cookies的文件名，默认为 'cookies.txt'

    Returns:
        int: 成功返回0，失败返回1
    """
    async with async_playwright() as p:
        browser = None
        try:
            # 连接到本地运行的Chrome浏览器
            print("尝试连接到 Chrome 浏览器 (http://localhost:9222)...")
            browser = await p.chromium.connect_over_cdp("http://localhost:9222")    
            print("成功连接到 Chrome 浏览器。")
            default_context = browser.contexts[0]  # 获取默认上下文
            cookies = await default_context.cookies()
            print(f"获取到 {len(cookies)} 个 cookies。")
            
            # 直接保存为Netscape格式的cookies文件
            convert_json_to_netscape_cookies(cookies, output_file)
            print(f"Cookies已保存到 {output_file} 文件")
        except Exception as e:
            print(f"保存cookies时出错: {e}")
            print("请确保 Chrome 浏览器已通过远程调试模式启动，并且端口为 9222。")
            return 1
        finally:
            if browser:
                await browser.close()
                print("已关闭与 Chrome 浏览器的连接。")
    return 0

def convert_json_to_netscape_cookies(cookies, netscape_file):
    """
    将JSON格式的cookies转换为Netscape格式
    
    Args:
        cookies (list): JSON格式的cookies列表
        netscape_file (str): 输出的Netscape格式cookies文件路径
    """
    try:
        # 创建Netscape格式的cookies文件
        with open(netscape_file, 'w', encoding='utf-8') as f:
            # 写入Netscape cookies文件头
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# https://curl.haxx.se/docs/http-cookies.html\n")
            f.write("# This file was generated by a script, not yt-dlp directly.\n\n") # 更新注释
            
            # 写入每个cookie
            for cookie in cookies:
                domain_from_playwright = cookie.get('domain', '')  # e.g., '.google.com' or 'google.com'
                
                # Determine domain_specified based on whether domain_from_playwright starts with a dot.
                is_domain_wide = domain_from_playwright.startswith('.')
                domain_specified_val = 'TRUE' if is_domain_wide else 'FALSE'
                
                # The domain written to the file should match the domain_specified_val rule:
                # If domain_specified_val is TRUE, domain in file must start with '.'
                # If domain_specified_val is FALSE, domain in file must NOT start with '.'
                # Playwright's domain (domain_from_playwright) already adheres to this.
                domain_for_file = domain_from_playwright
                
                path = cookie.get('path', '/')
                secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                
                # Ensure expires is a valid integer.
                # Netscape format uses 0 for session cookies.
                expires_val = cookie.get('expires', -1) # Default to -1 to clearly indicate session if not present
                if not isinstance(expires_val, (int, float)) or expires_val <= 0:
                    expires_for_file = 0  # Session cookie or invalid/past expiry
                else:
                    expires_for_file = int(expires_val)
                
                name = cookie.get('name', '')
                value = cookie.get('value', '')
                
                # Netscape format: domain<tab>domain_specified<tab>path<tab>secure<tab>expiry<tab>name<tab>value
                f.write(f"{domain_for_file}\t{domain_specified_val}\t{path}\t{secure}\t{expires_for_file}\t{name}\t{value}\n")
                
        print(f"Cookies已转换为Netscape格式并保存到 {netscape_file}")
    except Exception as e:
        print(f"转换cookies格式时出错: {e}")
        raise

if __name__ == "__main__":
    print("YouTube视频下载工具 - Cookies提取器")
    print("="*50)
    print("本工具将启动Chrome浏览器，请在浏览器中登录YouTube (或其他网站)。")
    print("登录完成后，按回车键，工具将自动保存cookies到 cookies.txt 文件。")
    print("之后您可以使用yt-dlp或类似工具下载视频，例如:")
    print("yt-dlp --cookies cookies.txt [视频URL]")
    print("="*50)
    
    chrome_process = None # 初始化 chrome_process
    try:
        # 启动Chrome并开启远程调试
        chrome_process = launch_chrome_with_remote_debugging()
        
        if chrome_process:
            # 运行异步函数保存cookies
            exit_code = asyncio.run(save_cookies_async())
            
            if exit_code == 0:
                print("\n操作成功完成！")
                print(f"Cookies已保存到 cookies.txt。您现在可以使用它配合下载工具。")
            else:
                print("\n操作失败，请检查上面的错误信息。")
        else:
            print("未能启动 Chrome 浏览器，程序退出。")

    except KeyboardInterrupt:
        print("\n用户中断操作。")
    except Exception as e:
        print(f"发生意外错误: {e}")
    finally:
        if chrome_process:
            print("正在尝试关闭Chrome进程...")
            chrome_process.terminate()
            try:
                chrome_process.wait(timeout=5) # 等待进程终止
                print("Chrome进程已关闭。")
            except subprocess.TimeoutExpired:
                print("关闭Chrome进程超时，可能需要手动关闭。")
                chrome_process.kill()
                print("已强制终止Chrome进程。")
        print("程序已退出。")
